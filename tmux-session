#!/usr/bin/env bash
set -euo pipefail

# tmux-session: Interactive tmux session manager with AI summaries
# Pure bash, zero external dependencies (except tmux, curl, jq for AI features)

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/lib/constants.sh"
source "${SCRIPT_DIR}/lib/utils.sh"
source "${SCRIPT_DIR}/lib/sessions.sh"
source "${SCRIPT_DIR}/lib/ai.sh"

# ─── TUI Rendering ───────────────────────────────────────────────────

draw_header() {
    cursor_to 1 1
    clear_line
    printf "${BOLD}${CYAN} tmux-session manager${RESET}${DIM}  v${VERSION}${RESET}"
    cursor_to 2 1
    clear_line
    local separator=""
    local max_w=$(( TERM_COLS - 2 ))
    for (( c=0; c<max_w; c++ )); do separator+="─"; done
    printf " ${DIM}${separator}${RESET}"
}

draw_session_list() {
    local start_row=3
    local max_items=$(( (TERM_ROWS - 10) / 2 ))  # Reserve space for preview + footer
    if (( max_items < 3 )); then max_items=3; fi
    if (( max_items > ${#SESSIONS[@]} )); then max_items=${#SESSIONS[@]}; fi

    # Calculate scroll offset
    local offset=0
    if (( SELECTED >= max_items )); then
        offset=$(( SELECTED - max_items + 1 ))
    fi

    local i
    for (( i=0; i<max_items; i++ )); do
        local idx=$(( offset + i ))
        if (( idx >= ${#SESSIONS[@]} )); then break; fi

        local row=$(( start_row + i ))
        cursor_to "$row" 1
        clear_line

        local session="${SESSIONS[$idx]}"
        local ai_text=""
        if [[ -n "${AI_SUMMARIES[$idx]:-}" ]]; then
            ai_text="${CYAN} [${AI_SUMMARIES[$idx]}]${RESET}"
        elif ai_enabled; then
            ai_text="${DIM} [...]${RESET}"
        fi

        if (( idx == SELECTED )); then
            printf " ${REVERSE}${BOLD} > %-20s${RESET}${ai_text}" "$session"
        else
            printf "   %-20s${ai_text}" "$session"
        fi
    done

    # Clear any leftover lines from previous render
    local clear_row=$(( start_row + max_items ))
    cursor_to "$clear_row" 1
    clear_line

    LIST_END=$(( start_row + max_items ))
}

draw_separator() {
    local row="$1"
    cursor_to "$row" 1
    clear_line
    local separator=""
    local max_w=$(( TERM_COLS - 2 ))
    for (( c=0; c<max_w; c++ )); do separator+="─"; done
    printf " ${DIM}${separator}${RESET}"
}

draw_preview() {
    local preview_start="$1"

    if [[ ${#SESSIONS[@]} -eq 0 ]]; then
        cursor_to "$preview_start" 1
        clear_line
        printf " ${DIM}No tmux sessions found. Press [n] to create one.${RESET}"
        return
    fi

    local session="${SESSIONS[$SELECTED]}"
    cursor_to "$preview_start" 1
    clear_line
    printf " ${BOLD}Preview${RESET} ${DIM}(${session}):${RESET}"

    local preview_content
    preview_content=$(capture_pane "$session" "$PREVIEW_LINES")

    local line_num=0
    local max_preview_lines=$(( TERM_ROWS - preview_start - 4 ))
    if (( max_preview_lines < 3 )); then max_preview_lines=3; fi

    while IFS= read -r line; do
        line_num=$(( line_num + 1 ))
        if (( line_num > max_preview_lines )); then break; fi

        local row=$(( preview_start + line_num ))
        cursor_to "$row" 1
        clear_line
        # Truncate line to the smaller of terminal width and PREVIEW_MAX_COLS
        local max_len=$(( TERM_COLS - 2 ))
        if (( PREVIEW_MAX_COLS < max_len )); then max_len=$PREVIEW_MAX_COLS; fi
        printf " ${GRAY}%s${RESET}" "${line:0:$max_len}"
    done <<< "$preview_content"

    # Clear remaining preview lines
    local r
    for (( r = preview_start + line_num + 1; r <= TERM_ROWS - 3; r++ )); do
        cursor_to "$r" 1
        clear_line
    done
}

draw_footer() {
    local row=$(( TERM_ROWS - 1 ))

    # Separator
    cursor_to $(( row - 1 )) 1
    clear_line
    local separator=""
    local max_w=$(( TERM_COLS - 2 ))
    for (( c=0; c<max_w; c++ )); do separator+="─"; done
    printf " ${DIM}${separator}${RESET}"

    cursor_to "$row" 1
    clear_line
    printf " ${GREEN}[Enter]${RESET} attach  ${YELLOW}[r]${RESET} rename  ${RED}[k]${RESET} kill  ${BLUE}[n]${RESET} new  ${DIM}[f]${RESET} refresh  ${DIM}[q]${RESET} quit"
}

render() {
    get_term_size
    load_ai_results

    draw_header

    draw_session_list

    draw_separator $(( LIST_END + 1 ))
    draw_preview $(( LIST_END + 2 ))
    draw_footer
}

# ─── Actions ──────────────────────────────────────────────────────────

action_attach() {
    if [[ ${#SESSIONS[@]} -eq 0 ]]; then return; fi
    local session="${SESSIONS[$SELECTED]}"
    cursor_show
    clear_screen
    # Restore terminal before attaching
    stty "$SAVED_TTY" 2>/dev/null || true
    tmux attach -t "$session"
    # After detach, re-setup terminal
    SAVED_TTY=$(stty -g 2>/dev/null || true)
    stty -echo -icanon min 1 time 0 2>/dev/null || true
    cursor_hide
    refresh_sessions
    start_ai_summaries
    render
}

action_rename() {
    if [[ ${#SESSIONS[@]} -eq 0 ]]; then return; fi
    local session="${SESSIONS[$SELECTED]}"
    local suggested="${AI_NAMES[$SELECTED]:-}"

    # Show rename prompt
    cursor_show
    local prompt_row=$(( TERM_ROWS ))
    cursor_to "$prompt_row" 1
    clear_line

    # Restore terminal for input
    stty "$SAVED_TTY" 2>/dev/null || true
    stty echo icanon 2>/dev/null || true

    local new_name=""
    if [[ -n "$suggested" ]]; then
        printf " ${BOLD}Rename '${session}' to${RESET} [${DIM}${suggested}${RESET}] (ESC/empty=cancel): "
        IFS= read -r -e -i "$suggested" new_name || true
    else
        printf " ${BOLD}Rename '${session}' to${RESET} (ESC/empty=cancel): "
        IFS= read -r -e new_name || true
    fi

    # Re-setup raw terminal
    stty -echo -icanon min 1 time 0 2>/dev/null || true
    cursor_hide

    # Clear the prompt line
    cursor_to "$prompt_row" 1
    clear_line

    if [[ -n "$new_name" ]]; then
        tmux rename-session -t "$session" "$new_name" 2>/dev/null || true
        refresh_sessions
    fi
    render
}

action_kill() {
    if [[ ${#SESSIONS[@]} -eq 0 ]]; then return; fi
    local session="${SESSIONS[$SELECTED]}"

    # Show confirm prompt (stay in raw mode, read single key without Enter)
    local prompt_row=$(( TERM_ROWS ))
    cursor_to "$prompt_row" 1
    clear_line
    printf " ${RED}${BOLD}Kill session '${session}'? [y/N]${RESET} "

    local confirm=""
    IFS= read -r -s -n 1 confirm 2>/dev/null || true

    # Clear the prompt line
    cursor_to "$prompt_row" 1
    clear_line

    if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
        tmux kill-session -t "$session" 2>/dev/null || true
        refresh_sessions
    fi
    render
}

action_new() {
    cursor_show
    local prompt_row=$(( TERM_ROWS ))
    cursor_to "$prompt_row" 1
    clear_line

    stty "$SAVED_TTY" 2>/dev/null || true
    stty echo icanon 2>/dev/null || true

    printf " ${BOLD}New session name${RESET} (empty=cancel): "
    local name=""
    IFS= read -r -e name || true

    stty -echo -icanon min 1 time 0 2>/dev/null || true
    cursor_hide

    # Clear the prompt line
    cursor_to "$prompt_row" 1
    clear_line

    if [[ -n "$name" ]]; then
        tmux new-session -d -s "$name" 2>/dev/null || true
        refresh_sessions
        start_ai_summaries
    fi
    render
}

# ─── Input handling ───────────────────────────────────────────────────

read_key() {
    local key
    IFS= read -r -s -n 1 -t 0.5 key 2>/dev/null || { echo "TIMEOUT"; return; }

    if [[ "$key" == $'\x1b' ]]; then
        local seq1 seq2
        IFS= read -r -s -n 1 -t 0.1 seq1 2>/dev/null || true
        IFS= read -r -s -n 1 -t 0.1 seq2 2>/dev/null || true
        case "${seq1}${seq2}" in
            '[A') echo "UP" ;;
            '[B') echo "DOWN" ;;
            *)    echo "ESC" ;;
        esac
    elif [[ "$key" == "" ]]; then
        echo "ENTER"
    else
        echo "$key"
    fi
}

handle_input() {
    local key
    key=$(read_key)

    case "$key" in
        UP)
            if (( SELECTED > 0 )); then
                SELECTED=$(( SELECTED - 1 ))
            fi
            ;;
        DOWN)
            if (( ${#SESSIONS[@]} > 0 && SELECTED < ${#SESSIONS[@]} - 1 )); then
                SELECTED=$(( SELECTED + 1 ))
            fi
            ;;
        ENTER)
            action_attach
            ;;
        r)
            action_rename
            ;;
        f)
            refresh_sessions
            start_ai_summaries
            ;;
        k)
            action_kill
            ;;
        n)
            action_new
            ;;
        q)
            RUNNING=false
            ;;
        TIMEOUT)
            # Just re-render to pick up AI results
            ;;
    esac
}

# ─── Cleanup and main ────────────────────────────────────────────────

SAVED_TTY=""

cleanup() {
    cursor_show
    clear_screen
    cursor_to 1 1
    cleanup_ai
    if [[ -n "$SAVED_TTY" ]]; then
        stty "$SAVED_TTY" 2>/dev/null || true
    fi
}

main() {
    check_deps

    # Handle --version / --help
    case "${1:-}" in
        --version|-v) echo "tmux-session v${VERSION}"; exit 0 ;;
        --help|-h)
            echo "tmux-session v${VERSION} - Interactive tmux session manager"
            echo ""
            echo "Usage: tmux-session"
            echo ""
            echo "Keys:"
            echo "  Up/Down  Navigate sessions"
            echo "  Enter    Attach to selected session"
            echo "  r        Rename session (with AI suggestion)"
            echo "  k        Kill session"
            echo "  n        New session"
            echo "  f        Refresh session list + AI summaries"
            echo "  q        Quit"
            echo ""
            echo "Environment:"
            echo "  ANTHROPIC_API_KEY  Set to enable AI summaries (uses Haiku)"
            exit 0
            ;;
    esac

    # Save terminal state and setup raw mode
    SAVED_TTY=$(stty -g 2>/dev/null || true)
    trap cleanup EXIT INT TERM
    stty -echo -icanon min 1 time 0 2>/dev/null || true

    cursor_hide
    clear_screen

    refresh_sessions
    start_ai_summaries
    render

    while $RUNNING; do
        handle_input
        render
    done
}

main "$@"
