#!/usr/bin/env bash
set -euo pipefail

# tmux-session: Interactive tmux session manager with AI summaries
# Pure bash, zero external dependencies (except tmux, curl, jq for AI features)

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/lib/constants.sh"
source "${SCRIPT_DIR}/lib/utils.sh"
source "${SCRIPT_DIR}/lib/sessions.sh"
source "${SCRIPT_DIR}/lib/ai.sh"
source "${SCRIPT_DIR}/lib/render.sh"

# ─── Actions ──────────────────────────────────────────────────────────

action_attach() {
    if [[ ${#SESSIONS[@]} -eq 0 ]]; then return; fi
    local session="${SESSIONS[$SELECTED]}"
    cursor_show
    clear_screen
    # Restore terminal before attaching
    stty "$SAVED_TTY" 2>/dev/null || true
    tmux attach -t "$session"
    # After detach, re-setup terminal
    SAVED_TTY=$(stty -g 2>/dev/null || true)
    stty -echo -icanon min 1 time 0 2>/dev/null || true
    cursor_hide
    refresh_sessions
    start_ai_summaries
    render
}

action_rename() {
    if [[ ${#SESSIONS[@]} -eq 0 ]]; then return; fi
    local session="${SESSIONS[$SELECTED]}"
    local suggested="${AI_NAMES[$SELECTED]:-}"

    # Show rename prompt
    cursor_show
    local prompt_row=$(( TERM_ROWS ))
    cursor_to "$prompt_row" 1
    clear_line

    # Restore terminal for input
    stty "$SAVED_TTY" 2>/dev/null || true
    stty echo icanon 2>/dev/null || true

    local new_name=""
    if [[ -n "$suggested" ]]; then
        printf " ${BOLD}Rename '${session}' to${RESET} [${DIM}${suggested}${RESET}] (ESC/empty=cancel): "
        IFS= read -r -e -i "$suggested" new_name || true
    else
        printf " ${BOLD}Rename '${session}' to${RESET} (ESC/empty=cancel): "
        IFS= read -r -e new_name || true
    fi

    # Re-setup raw terminal
    stty -echo -icanon min 1 time 0 2>/dev/null || true
    cursor_hide

    # Clear the prompt line
    cursor_to "$prompt_row" 1
    clear_line

    if [[ -n "$new_name" ]]; then
        tmux rename-session -t "$session" "$new_name" 2>/dev/null || true
        refresh_sessions
    fi
    render
}

action_kill() {
    if [[ ${#SESSIONS[@]} -eq 0 ]]; then return; fi
    local session="${SESSIONS[$SELECTED]}"

    # Show confirm prompt (stay in raw mode, read single key without Enter)
    local prompt_row=$(( TERM_ROWS ))
    cursor_to "$prompt_row" 1
    clear_line
    printf " ${RED}${BOLD}Kill session '${session}'? [y/N]${RESET} "

    local confirm=""
    IFS= read -r -s -n 1 confirm 2>/dev/null || true

    # Clear the prompt line
    cursor_to "$prompt_row" 1
    clear_line

    if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
        tmux kill-session -t "$session" 2>/dev/null || true
        refresh_sessions
    fi
    render
}

action_new() {
    cursor_show
    local prompt_row=$(( TERM_ROWS ))
    cursor_to "$prompt_row" 1
    clear_line

    stty "$SAVED_TTY" 2>/dev/null || true
    stty echo icanon 2>/dev/null || true

    printf " ${BOLD}New session name${RESET} (empty=cancel): "
    local name=""
    IFS= read -r -e name || true

    stty -echo -icanon min 1 time 0 2>/dev/null || true
    cursor_hide

    # Clear the prompt line
    cursor_to "$prompt_row" 1
    clear_line

    if [[ -n "$name" ]]; then
        tmux new-session -d -s "$name" 2>/dev/null || true
        refresh_sessions
        start_ai_summaries
    fi
    render
}

# ─── Input handling ───────────────────────────────────────────────────

read_key() {
    local key
    IFS= read -r -s -n 1 -t 0.5 key 2>/dev/null || { echo "TIMEOUT"; return; }

    if [[ "$key" == $'\x1b' ]]; then
        local seq1 seq2
        IFS= read -r -s -n 1 -t 0.1 seq1 2>/dev/null || true
        IFS= read -r -s -n 1 -t 0.1 seq2 2>/dev/null || true
        case "${seq1}${seq2}" in
            '[A') echo "UP" ;;
            '[B') echo "DOWN" ;;
            *)    echo "ESC" ;;
        esac
    elif [[ "$key" == "" ]]; then
        echo "ENTER"
    else
        echo "$key"
    fi
}

handle_input() {
    local key
    key=$(read_key)

    case "$key" in
        UP)
            if (( SELECTED > 0 )); then
                SELECTED=$(( SELECTED - 1 ))
            fi
            ;;
        DOWN)
            if (( ${#SESSIONS[@]} > 0 && SELECTED < ${#SESSIONS[@]} - 1 )); then
                SELECTED=$(( SELECTED + 1 ))
            fi
            ;;
        ENTER)
            action_attach
            ;;
        r)
            action_rename
            ;;
        f)
            refresh_sessions
            start_ai_summaries
            ;;
        k)
            action_kill
            ;;
        n)
            action_new
            ;;
        q)
            RUNNING=false
            ;;
        TIMEOUT)
            # Just re-render to pick up AI results
            ;;
    esac
}

# ─── Cleanup and main ────────────────────────────────────────────────

SAVED_TTY=""

cleanup() {
    cursor_show
    clear_screen
    cursor_to 1 1
    cleanup_ai
    if [[ -n "$SAVED_TTY" ]]; then
        stty "$SAVED_TTY" 2>/dev/null || true
    fi
}

main() {
    check_deps

    # Handle --version / --help
    case "${1:-}" in
        --version|-v) echo "tmux-session v${VERSION}"; exit 0 ;;
        --help|-h)
            echo "tmux-session v${VERSION} - Interactive tmux session manager"
            echo ""
            echo "Usage: tmux-session"
            echo ""
            echo "Keys:"
            echo "  Up/Down  Navigate sessions"
            echo "  Enter    Attach to selected session"
            echo "  r        Rename session (with AI suggestion)"
            echo "  k        Kill session"
            echo "  n        New session"
            echo "  f        Refresh session list + AI summaries"
            echo "  q        Quit"
            echo ""
            echo "Environment:"
            echo "  ANTHROPIC_API_KEY  Set to enable AI summaries (uses Haiku)"
            exit 0
            ;;
    esac

    # Save terminal state and setup raw mode
    SAVED_TTY=$(stty -g 2>/dev/null || true)
    trap cleanup EXIT INT TERM
    stty -echo -icanon min 1 time 0 2>/dev/null || true

    cursor_hide
    clear_screen

    refresh_sessions
    start_ai_summaries
    render

    while $RUNNING; do
        handle_input
        render
    done
}

main "$@"
